<!DOCTYPE html>
<html lang="fr">

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta charset="utf-8" />
    <meta name="theme-color" content="#5f7995" />
    <meta name="author" content="Jeremy Keith" />
    <meta name="description" content="Chapter Four: Languages" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@adactio" />
    <meta name="twitter:creator" content="@adactio" />
    <meta name="twitter:title" property="og:title" content="Resilient Web Design—Chapter 4" />
    <meta name="twitter:description" property="og:description" content="Chapter Four: Languages" />
    <meta name="twitter:url" property="og:url" content="https://resilientwebdesign.com/chapter4/" />
    <meta name="twitter:image" property="og:image"
        content="https://resilientwebdesign.com/chapter4/images/medium/jon-postel.jpg" />
    <title>Resilient Web Design—Chapter 4</title>
    <link rel="preload" href="../fonts/etbookot-roman-webfont.woff2" crossorigin type="font/woff2" as="font" />
    <link rel="preload" href="../js/scripts.js" as="script" />
    <link rel="stylesheet" href="../css/styles.css" />
    <link rel="contents" href="../contents/" />
    <link rel="author" href="../author/" />
    <link rel="prev" href="../chapter3/" />
    <link rel="next prefetch" href="../chapter5/" />
    <link rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/" />
    <link rel="amphtml" href="amp.html" />
    <link rel="manifest" href="../manifest.json" />
    <link rel="icon shortcut" href="../images/icon512.png" sizes="512x512" type="image/png" />
    <link rel="apple-touch-icon" href="../images/icon512.png" type="image/png" />
    <link rel="icon" href="../favicon.ico" type="image/x-icon" />
</head>

<body>

    <header>
        <a href="../">Resilient Web Design</a>
    </header>

    <main>

        <h1><span>Chapitre 4 :</span> Langages</h1>

        <p><span id="Jon%20Postel">Jon Postel</span>était l’un des ingénieurs qui travaillait sur
            l'<abbr>ARPANET</abbr>, le précurseur d’Internet. Il voulait s’assurer que les paquets - ou les
            “datagrammes” - qui étaient transportés à travers le réseau étaient livrés le plus efficacement possible. Il
            a réalisé qu’une approche laxiste des erreurs était cruciale pour un remplacement de paquets efficace.</p>

        <figure>
            <picture>
                <source media="all and (min-width: 75em)" srcset="images/large/jon-postel.jpg" />
                <source media="all and (min-width: 50em)"
                    srcset="images/medium/jon-postel.jpg, images/large/jon-postel.jpg 1.5x" />
                <img src="images/small/jon-postel.jpg"
                    alt="Jon Postel standing by a hand‐drawn diagram of the early internet."
                    srcset="images/medium/jon-postel.jpg 2x, images/large/jon-postel.jpg 3x" />
            </picture>
            <figcaption>Jon Postel.
                <small>Photographié par Irene Fertik, <abbr>USC</abbr> Service d’information.</small>
                <small>Droits d’auteur 1994, <abbr>USC</abbr>.</small>
            </figcaption>
        </figure>

        <p>Si sur le réseau, un nœud reçoit un datagramme qui a des erreurs, mais qui est toujours compréhensible, alors
            le paquet devrait quand même fonctionner.
            Inversement, chaque nœud sur le réseau devrait essayer d’envoyer des paquets bien constitués. Cette ligne de
            pensée a été consacrée au Principe de Robustess aussi connu comme la loi de Postel :</p>

        <blockquote>
            <p>“Soit conservateur dans ce que tu envoies, soit libéral dans ce que tu acceptes.”</p>
        </blockquote>

        <p>Si cela semble familier, c’est parce que c’est de cette manière que les navigateurs traitent
            <abbr>HTML</abbr> and
            <abbr>CSS</abbr>. Même s' il y a des erreurs dans l'<abbr>HTML</abbr> ou <abbr>CSS</abbr>, le navigateur
            essaiera quand même de transmettre l’information en sautant les parties qu’il n’arrive pas à analyser.
        </p>

        <section aria-labelledby="declaration">

            <h2 id="declaration">Déclaration</h2>

            <p><abbr>HTML</abbr> et <abbr>CSS</abbr> ont tous les deux des exemples de langages déclaratifs. Un auteur
                écrivant dans un langage déclaratif décrit un résultat souhaité sans fournir des instructions étapes par
                étapes à l’ordinateur qui traite le fichier. Avec <abbr>HTML</abbr>, vous pouvez décrire la nature du
                contenu - paragraphes, rubriques, champs de formulaires, etc. - sans avoir à expliquer exactement ce que
                le navigateur doit faire avec ces informations. Avec le <abbr>CSS</abbr>, vous pouvez décrire
                l’apparence souhaitée du contenu - couleur, bordures, etc. - sans avoir à écrire un programme pour
                appliquer ces styles.
            </p>

            <p>La plupart des langages de programmation ne sont pas déclaratifs, ils sont impératifs. Perl, Java, C++ …
                voilà des exemples de langages impératifs. Si vous écrivez avec un de ces langages, vous devez donner
                des instructions précises pour que l’ordinateur comprenne le code.
            </p>

            <p>Les langages impératives vous offrent plus de puissance et de précision que les langues déclaratives.
                Cela a un prix. Les langues impératives ont tendance à être plus difficiles à apprendre que les langues
                déclaratives. Il est également plus difficile d'appliquer la loi de Postel aux langues impératives. Si
                vous faites une seule erreur - une virgule ou un point-virgule mal placé - le programme entier peut
                échouer. Une balise mal orthographiée en <abbr>HTML</abbr> ou une accolade manquante en
                <abbr>CSS</abbr> peuvent également causer des maux de tête, mais les programmes impératifs doivent être
                bien formés, sinon ils ne fonctionneront pas du tout.
            </p>

            <p>Des langages impératifs tels que <abbr>PHP</abbr>, Ruby, et Python se trouvent sur les serveurs qui
                alimentent le World Wide Web, lisent et écrivent les enregistrements des bases de données, traitent les
                entrées et exécutent des algorithmes complexes. Vous pouvez choisir à peu près n'importe quel langage de
                programmation lorsque vous écrivez du code côté serveur. Contrairement à l'inconnaissabilité du
                navigateur web de l'utilisateur final, vous avez le contrôle des capacités de votre serveur.
            </p>

            <p>Si vous voulez écrire du code impératif qui fonctionne dans un navigateur web, vous n'avez qu'un seul
                choix :<span id="JavaScript">JavaScript</span>.</p>

        </section>

        <section aria-labelledby="scripting">

            <h2 id="scripting">Script</h2>

            <p>L'idée d'exécuter un programme à partir d'une page Web est aussi ancienne que le Web lui-même. Voici un
                premier e-mail à la liste de diffusion www-talk:</p>

            <blockquote>
                <p>“J’aimerais savoir si quelqu'un a étendu <abbr>WWW</abbr>de telle sorte qu'il soit possible de
                    démarrer des programmes arbitraires en appuyant sur un bouton dans un navigateur
                    <abbr>WWW</abbr>.
                </p>
            </blockquote>

            <p>Tim Berners‐Lee, le créateur du World Wide Web a répondu:</p>

            <blockquote>
                <p>“Très bonne question. Le problème est celui du langage de programmation. Vous avez besoin de quelque
                    chose de vraiment puissant, mais en même temps omniprésent. N'oubliez pas qu'une facette du Web est
                    le lectorat universel. Il n'y a pas de langage de programmation interprété universel.”</p>
            </blockquote>

            <p>C’était en 1992. Le langage de programmation interprété universel est finalement arrivé en 1996. Il a été
                écrit en dix jours par un programmeur de Netscape nommé <span id="Brendan%20Eich">Brendan Eich</span>.
            </p>

            <p>La langue a subi quelques changements de nom. D'abord, elle s'appelait Mocha. Ensuite, elle a été
                officiellement lancée en tant que LiveScript. Le département marketing l'a ensuite adopté et renommé
                JavaScript, espérant que le nom surpasserait la vague de publicité associée au nouveau langage Java de
                l'époque. En réalité, ces langues n'ont pas grand-chose en commun. Java est au JavaScript ce que le
                jambon est au hamster.</p>

        </section>

        <section aria-labelledby="patternsofprogress">

            <h2 id="patternsofprogress">Modèles de progrès</h2>

            <p>JavaScript a donné aux designers le pouvoir de mettre à jour les pages web même après leur chargement.
                Deux utilisations communes sont rapidement apparues : la reconduction et la validation des formulaires.
            </p>

            <p>L'échange d'images lorsque quelqu'un passe son curseur sur un lien peut ne semble peut être pas être une
                utilisation judicieuse d'un tout nouveau langage de programmation, mais dans les années 90, il n'y avait
                pas d'autre moyen de créer des effets de survol.</p>

            <p>Avant l'arrivée de JavaScript, un formulaire devait être soumis à un serveur web avant que vous puissiez
                vérifier que tous les champs requis étaient remplis ou que les informations saisies correspondaient à un
                format attendu.</p>

            <p>Ces deux cas d'utilisation existent toujours, mais il n'est plus nécessaire d'atteindre JavaScript. Vous
                pouvez créer des effets de survol en utilisant la pseudo-classe <code>:hover</code>dans le
                <abbr>CSS</abbr>.Vous pouvez valider les champs du formulaire en utilisant les attributs <code
                    class="markup attribute">REQUIRED</code> et <code class="markup attribute">TYPE</code> en
                <abbr>HTML</abbr>.
            </p>

            <p>C'est un schéma qui se répète sans cesse : une solution est créée dans une langue impérative et si elle
                est assez populaire, elle migre vers une langue déclarative au fil du temps. Lorsqu'une fonctionnalité
                est disponible dans une langue déclarative, non seulement elle est plus facile à écrire, mais elle est
                aussi plus résistante.
            </p>

            <p>Le traitement souple des erreurs du <abbr>HTML</abbr> et <abbr>CSS</abbr> signifie que de nombreuses
                erreurs de création ou des problèmes de prise en charge du navigateur sont traités avec grâce ; le
                navigateur ignore simplement ce qu'il ne comprend pas et continue. C'est souvent suffisant. En revanche,
                si vous donnez à un navigateur un JavaScript mal formé ou si vous essayez d'utiliser une fonction
                JavaScript non prise en charge, non seulement le navigateur lancera une erreur, mais il cessera
                d'analyser le script à ce moment-là et refusera d'aller plus loin.</p>

        </section>

        <section aria-labelledby="responsibility">

            <h2 id="responsibility">Responsabilité</h2>

            <p>JavaScript a donné aux concepteurs de sites web le pouvoir de créer des sites plus lisses, plus fluides
                et plus réactifs. La même technologie a également donné aux concepteurs de sites web le pouvoir de créer
                des sites web plus lents, plus lourds et plus difficiles à utiliser.</p>

            <p>L'un des premiers abus de JavaScript est venu (sans surprise) de l'industrie de la publicité, une
                entreprise dont la raison d'être même est souvent en contradiction avec les objectifs des personnes qui
                essaient d'accomplir une tâche le plus rapidement possible. Le JavaScript permet de créer de nouvelles
                fenêtres de navigation, ce qui, auparavant, ne pouvait être fait que par l'utilisateur. Un jeune
                développeur nommé <span id="Ethan%20Zuckerman">Ethan Zuckerman</span> s'est rendu compte qu'il pouvait
                créer une nouvelle fenêtre contenant une publicité. Cela a permis aux
                annonceurs de faire passer leur message aux visiteurs du site. De plus, le JavaScript pouvait être
                utilisé pour créer plusieurs fenêtres, certaines visibles, d'autres cachées derrière la fenêtre
                actuelle. C'était une solution diabolique</p>

            <p>Vingt ans plus tard, Zuckerman a écrit :</p>

            <blockquote>
                <p>“J'ai écrit le code pour lancer la fenêtre et y faire passer une annonce. Je suis désolé.”</p>
            </blockquote>

            <p>Les fenêtres pop-up (et pop-under) sont devenues si intolérables que les navigateurs ont dû fournir aux
                gens un moyen de les bloquer.</p>

            <p>Le secteur de la publicité a ensuite trouvé d'autres moyens d'abuser de JavaScript. Les éditeurs en ligne
                soutenus par la publicité injectaient du JavaScript gonflé et inefficace dans
                leurs pages, ce qui les rendaient lentes à charger. Le JavaScript était également utilisé pour suivre
                les internautes d'un site à l'autre. Pour lutter contre ce traitement, les internautes ont eu recours à
                des logiciels de blocage des publicités. Finalement, le blocage des publicités a été intégré dans les
                navigateurs et les systèmes d'exploitation pour nous permettre de lutter contre le JavaScript excessif.
            </p>

            <p>Les concepteurs de sites web feraient bien de se rappeler ce que le secteur de la publicité a choisi
                d'ignorer : sur le web, c'est l'utilisateur qui a le dernier mot.</p>

        </section>

        <section aria-labelledby="twopointzero">

            <h2 id="twopointzero">2.0</h2>

            <p>L'essor de JavaScript a été stimulé en 2005 par la publication d'un article intitulé <cite
                    id="Ajax:%20A%20New%20Approach%20to%20Web%20Applications">Ajax: A New Approach to Web
                    Applications</cite> par <span id="Jesse%20James%20Garrett">Jesse James Garrett</span>. L'article a
                donné un nom à une technique qui gagnait en popularité. En utilisant un sous-ensemble spécifique de
                JavaScript, il était possible pour un navigateur web d'envoyer et de recevoir des données depuis un
                serveur web sans avoir à rafraîchir la page entière. Le résultat était une expérience utilisateur plus
                fluide.</p>

            <p>Le terme Ajax a été inventé en même temps qu'un autre néologisme était en plein essor.<span
                    id="Tim%20O’Reilly">Tim O’Reilly</span> a utilisé l'expression <span id="Web%202.0">Web 2.0</span>
                pour décrire une nouvelle vague de produits et services Web. Contrairement à Ajax, il était difficile de
                définir le Web 2.0. Pour les hommes d'affaires, cela signifiait de nouveaux modèles commerciaux. Pour
                les graphistes, cela signifiait des coins arrondis et des gradients. Pour les développeurs, cela
                signifiait JavaScript et Ajax.</p>

            <p>Quelle que soit sa signification exacte, le terme "Web 2.0" traduit une humeur et un sentiment. Tout
                allait être différent maintenant. Les anciennes façons de penser à la construction pour le web pouvaient
                être mises de côté. Il est révolu le temps où l'on considérait le web comme une collection illimitée de
                documents hyperliés. L'ère des applications web était proche.</p>

        </section>

        <section aria-labelledby="appiness">

            <h2 id="appiness">Appiness</h2>

            <p>In the 1964 supreme court case <span id="Jacobellis%20versus%20Ohio">Jacobellis versus Ohio</span>,
                Justice <span id="Potter%20Stewart">Potter Stewart</span> provided this definition of obscenity:</p>

            <blockquote>
                <p>I know it when I see it.</p>
            </blockquote>

            <p>The same could be said for Web 2.0, or for the term “web app.” We can all point to examples of web apps,
                but it’s trickier to provide a definition for the term. Web apps allow people to create, edit, and
                delete content. But these tasks were common long before web apps arrived. People could fill in forms and
                submit them to a web server for processing. Ajax removed the necessity for that round trip to
                the server.</p>

            <p>Perhaps the definition of a web app requires some circular reasoning:</p>

            <ul>
                <li>JavaScript is a requirement for a web app, and</li>
                <li>a web app is a website that requires JavaScript to work.</li>
            </ul>

            <p>In that case, building web apps depends on a fundamental assumption: JavaScript must be available and
                reliable. But because of its imperative nature, JavaScript tends to be more fragile than a declarative
                language like <abbr>HTML</abbr>. Relying on JavaScript might not be such a safe assumption after all.
            </p>

        </section>

        <section aria-labelledby="unforgiven">

            <h2 id="unforgiven">Unforgiven</h2>

            <p><abbr>HTML</abbr>’s loose error‐handling allowed it to grow in power over time. It also ensured that the
                language was easy to learn. Even if you made a mistake, the browser’s implementation of Postel’s Law
                ensured that you’d still get a result. Surprisingly, there was an attempt to remove this superpower
                from <abbr>HTML</abbr>.</p>

            <p>After the standardisation of <abbr>HTML</abbr> version 4 in 1999, the World Wide Web Consortium published
                <abbr id="XHTML">XHTML</abbr> 1.0. This reformulated <abbr>HTML</abbr> according to the rules of the
                <abbr id="XML">XML</abbr> data format. Whereas <abbr>HTML</abbr> can have uppercase or lowercase tag
                names and attributes, <abbr>XML</abbr> requires them to be all lowercase. There were some other
                differences: all attributes had to be quoted, and standalone elements like <code
                    class="markup element">IMG</code> or <code class="markup element">BR</code> required a
                closing slash.
            </p>

            <p><abbr>XHTML</abbr> 1.0 didn’t add any new features to the language. It was simply a stricter way of
                writing markup. <abbr>XHTML</abbr> 2.0 was a different proposition. Not only would it remove established
                elements like <code class="markup element">IMG</code>, it would also implement <abbr>XML</abbr>’s
                draconian error‐handling model. If there is a single error in an <abbr>XML</abbr> document—one unquoted
                attribute or missing closing slash—then the parser should stop immediately and refuse to
                render anything.</p>

            <p><abbr>XHTML</abbr> 2.0 died on the vine. Its theoretical purity was roundly rejected by the people who
                actually made websites for a living. Web designers rightly refused to publish in a format that would
                fail completely instead of trying to recover from an error.</p>

            <p>Strange then, that years later, web designers would happily create entire websites using JavaScript, a
                language that shares <abbr>XML</abbr>’s unforgiving error‐handling model. They didn’t call them
                websites. They called them web apps. That distinction was cold comfort to someone who couldn’t complete
                their task because a service relied on JavaScript for crucial functionality.</p>

            <p>Despite JavaScript’s fragile error‐handling model, web designers became more reliant on JavaScript over
                time. In 2015, <abbr id="NASA">NASA</abbr> relaunched its website as a web app. If you wanted to read
                the latest news of the agency’s space exploration efforts, you first had to download and execute three
                megabytes of JavaScript. This content—text and images—could have been delivered in the
                <abbr>HTML</abbr>, but the developers decided to use Ajax to retrieve this data instead. Until all that
                JavaScript was loaded, parsed, and executed, visitors to the site were left staring at a black
                background. Perhaps this was intended as a demonstration of the vast lonely emptiness of space.
            </p>

            <figure>
                <picture>
                    <source media="all and (min-width: 75em)" srcset="images/large/nasa.png" />
                    <source media="all and (min-width: 50em)"
                        srcset="images/medium/nasa.png, images/large/nasa.png 1.5x" />
                    <img src="images/small/nasa.png" alt="A web browser showing a black screen."
                        srcset="images/medium/nasa.png 2x, images/large/nasa.png 3x" />
                </picture>
                <figcaption>The 2015 version of the nasa.gov website with incomplete JavaScript.</figcaption>
            </figure>

            <p>This highlights another difference between <abbr>HTML</abbr> and JavaScript. Whereas <abbr>HTML</abbr>
                can be rendered piece by piece as it is downloaded, a JavaScript file must be downloaded in its entirety
                before its contents can be parsed. While it’s tempting to think that only a small minority of visitors
                will miss out on a site’s JavaScript, the truth is that everybody is a non‐JavaScript user until the
                JavaScript has finished loading ...<em>if</em> the JavaScript finishes loading. Flaky connections,
                interfering network operators, and unpredictable ad‐blocking software can torpedo the assumption that
                JavaScript will always be available.</p>

            <p>The problem is not with people deliberately disabling JavaScript in their browsers. Although that’s a use
                case worth considering, it’s not the most common cause of JavaScript errors. <span
                    id="Stuart%20Langridge">Stuart Langridge</span> put together a list of all the potential points of
                failure under the title <cite id="Everyone%20has%20JavaScript,%20right?">Everyone has
                    JavaScript, right?</cite></p>

            <blockquote>
                <p>The user requests your web app. Has the page loaded yet? Did the <abbr>HTTP</abbr> request for the
                    JavaScript succeed? Did the <abbr>HTTP</abbr> request for the JavaScript complete? Does the
                    corporate firewall block JavaScript? Does their <abbr>ISP</abbr> or mobile operator interfere with
                    downloaded JavaScript? Have they switched off JavaScript? Do they have add‐ons or plug‐ins installed
                    which inject script or alter the <abbr>DOM</abbr> in ways you didn’t anticipate? Is the Content
                    Delivery Network up? Does their browser support the JavaScript you’ve written?</p>
            </blockquote>

            <p>Many of those problems would also affect <abbr>HTML</abbr> and <abbr>CSS</abbr> files, but because of
                Postel’s Law, they can recover gracefully.</p>

            <p>This doesn’t mean that web designers shouldn’t use JavaScript. But it does mean that web designers
                shouldn’t <em>rely</em> on JavaScript when a simpler solution exists.</p>

        </section>

        <section aria-labelledby="platform">

            <h2 id="platform">Platform</h2>

            <p>Web designers who ignored the message of John Allsopp’s <cite>A Dao of Web Design</cite> made the mistake
                of treating the web like print. The history of print has much to offer—hierarchy, typography, colour
                theory—but the web is a fundamentally different medium. The history of software development also has
                much to offer—architecture, testing, process—but again, the web remains its own medium.</p>

            <p>It’s tempting to apply the knowledge and learnings from another medium to the web. But it is more
                structurally honest to uncover the web’s own unique strengths and weaknesses.</p>

            <p>The language we use can subtly influence our thinking. In his book <cite
                    id="Metaphors%20We%20Live%20By">Metaphors We Live By</cite>, <span id="George%20Lakoff">George
                    Lakoff</span> highlights the dangers of political language. Obvious examples are “friendly fire” and
                “collateral damage”, but a more insidious example is “tax relief”—before a debate has even begun,
                taxation has been framed as something requiring relief.</p>

            <p>On the face of it, the term “web platform” seems harmless. Describing the web as a platform puts it on
                par with other software environments. Flash was a platform. Android is a platform. i<abbr>OS</abbr> is a
                platform. But the web is not a platform. The whole point of the web is that it is
                <em>cross</em>‐platform.
            </p>

            <p>A platform provides a controlled runtime environment for software. As long as the user has that runtime
                environment, you can be confident that they will get exactly what you’ve designed. If you build an
                i<abbr>OS</abbr> app and someone has an i<abbr>OS</abbr> device, you know that they will get 100% of
                your software. But if you build an i<abbr>OS</abbr> app and someone has an Android device, they will get
                0% of your software. You can’t install an i<abbr>OS</abbr> app on an Android device. It’s all
                or nothing.</p>

            <p>The web isn’t as binary as that. If you build something using web technologies, and someone visits with a
                web browser, you can’t be sure how many of the web technologies will be supported. It probably won’t be
                100%. But it’s also unlikely to be 0%. Some people will visit with i<abbr>OS</abbr> devices. Others will
                visit with Android devices. Some people will get 80% or 90% of what you’ve designed. Others will get
                just 20%, 30%, or 50%. The web isn’t a platform. It’s a continuum.</p>

            <p>Thinking of the web as a platform is a category error. A platform like Flash, i<abbr>OS</abbr>, or
                Android provides stability and certainty, but only under a very specific set of circumstances—your
                software must be accessed with the right platform‐specific runtime environment. The web provides no such
                certainty, but it also doesn’t restrict the possible runtime environments.</p>

            <p>Platforms are controlled and predictable. The World Wide Web is chaotic and unpredictable.</p>

            <p>The web is a hot mess.</p>

        </section>

        <aside>
            <h2>References</h2>
            <ol>
                <li><a href="https://tools.ietf.org/html/rfc761#section-2.10"><abbr>RFC</abbr> 761: <cite>Transmission
                            Control Protocol</cite></a> by Jon Postel</li>
                <li><a href="https://lists.w3.org/Archives/Public/www-talk/1992MayJun/0006.html"><cite>Program Links in
                            <abbr>WWW</abbr></cite></a> by Tim Berners‐Lee</li>
                <li><a
                        href="http://www.theatlantic.com/technology/archive/2014/08/advertising-is-the-internets-original-sin/376041/"><cite>The
                            Internet’s Original Sin</cite></a> by Ethan Zuckerman</li>
                <li><a
                        href="https://web.archive.org/web/20150910072359/http://adaptivepath.org/ideas/ajax-new-approach-web-applications/"><cite>Ajax:
                            A New Approach to Web Applications</cite></a> by Jesse James Garrett</li>
                <li><a href="https://kryogenix.org/code/browser/everyonehasjs.html"><cite>Everyone has JavaScript,
                            right?</cite></a> by Stuart Langridge</li>
            </ol>
        </aside>

    </main>

    <nav>
        <a href="../chapter5/" rel="next"><cite><span>Chapter 5:</span> Layers</cite></a>
        <ol start="0">
            <li><a href="../introduction/"><cite>Introduction</cite></a></li>
            <li><a href="../chapter1/"><cite><span>Chapter 1</span> Foundations</cite></a></li>
            <li><a href="../chapter2/"><cite><span>Chapter 2</span> Materials</cite></a></li>
            <li><a href="../chapter3/"><cite><span>Chapter 3</span> Visions</cite></a></li>
            <li><a href="../chapter4/"><cite><span>Chapter 4</span> Languages</cite></a></li>
            <li><a href="../chapter5/"><cite><span>Chapter 5</span> Layers</cite></a></li>
            <li><a href="../chapter6/"><cite><span>Chapter 6</span> Steps</cite></a></li>
            <li><a href="../chapter7/"><cite><span>Chapter 7</span> Challenges</cite></a></li>
            <li><a href="../author/" rel="author"><cite>About the author</cite></a></li>
        </ol>
    </nav>

    <footer>
        <p><cite>Resilient Web Design</cite> was written and produced by <a href="https://adactio.com"
                class="v‐card">Jeremy Keith</a>, and typeset in <a
                href="https://edwardtufte.github.io/et-book/"><abbr>ET</abbr> Book</a>.</p>
        <p><small>Licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative
                    Commons Attribution‐ShareAlike 4.0 International License</a>.</small></p>
    </footer>

    <script src="../js/scripts.js" defer></script>
</body>

</html>