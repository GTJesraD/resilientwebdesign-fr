<!DOCTYPE html>
<html lang="en">

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta charset="utf-8" />
    <meta name="theme-color" content="#5f7995" />
    <meta name="author" content="Jeremy Keith" />
    <meta name="description" content="Chapter Four: Languages" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@adactio" />
    <meta name="twitter:creator" content="@adactio" />
    <meta name="twitter:title" property="og:title" content="Resilient Web Design—Chapter 4" />
    <meta name="twitter:description" property="og:description" content="Chapter Four: Languages" />
    <meta name="twitter:url" property="og:url" content="https://resilientwebdesign.com/chapter4/" />
    <meta name="twitter:image" property="og:image"
        content="https://resilientwebdesign.com/chapter4/images/medium/jon-postel.jpg" />
    <title>Resilient Web Design—Chapter 4</title>
    <link rel="preload" href="../fonts/etbookot-roman-webfont.woff2" crossorigin type="font/woff2" as="font" />
    <link rel="preload" href="../js/scripts.js" as="script" />
    <link rel="stylesheet" href="../css/styles.css" />
    <link rel="contents" href="../contents/" />
    <link rel="author" href="../author/" />
    <link rel="prev" href="../chapter3/" />
    <link rel="next prefetch" href="../chapter5/" />
    <link rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/" />
    <link rel="amphtml" href="amp.html" />
    <link rel="manifest" href="../manifest.json" />
    <link rel="icon shortcut" href="../images/icon512.png" sizes="512x512" type="image/png" />
    <link rel="apple-touch-icon" href="../images/icon512.png" type="image/png" />
    <link rel="icon" href="../favicon.ico" type="image/x-icon" />
</head>

<body>

    <header>
        <a href="../">Resilient Web Design</a>
    </header>

    <main>

        <h1><span>Chapter 4:</span> Languages</h1>

        <p><span id="Jon%20Postel">Jon Postel</span> was one of the engineers working on the <abbr>ARPANET</abbr>, the
            precursor to the internet. He wanted to make sure that the packets—or “datagrams”—being shuttled around the
            network were delivered in the most efficient way. He came to realise that a lax approach to errors was
            crucial to effective packet switching.</p>

        <figure>
            <picture>
                <source media="all and (min-width: 75em)" srcset="images/large/jon-postel.jpg" />
                <source media="all and (min-width: 50em)"
                    srcset="images/medium/jon-postel.jpg, images/large/jon-postel.jpg 1.5x" />
                <img src="images/small/jon-postel.jpg"
                    alt="Jon Postel standing by a hand‐drawn diagram of the early internet."
                    srcset="images/medium/jon-postel.jpg 2x, images/large/jon-postel.jpg 3x" />
            </picture>
            <figcaption>Jon Postel.
                <small>Photograph by Irene Fertik, <abbr>USC</abbr> News Service.</small>
                <small>Copyright 1994, <abbr>USC</abbr>.</small>
            </figcaption>
        </figure>

        <p>If a node on the network receives a datagram that has errors, but is still understandable, then the packet
            should be processed anyway. Conversely every node on the network should attempt to send well‐formed packets.
            This line of thinking was enshrined in the Robustness Principle, also known as Postel’s Law:</p>

        <blockquote>
            <p>Be conservative in what you send; be liberal in what you accept.</p>
        </blockquote>

        <p>If that sounds familiar, it’s because that’s the way that web browsers deal with <abbr>HTML</abbr> and
            <abbr>CSS</abbr>. Even if there are errors in the <abbr>HTML</abbr> or <abbr>CSS</abbr>, the browser will
            still attempt to process the information, skipping over any pieces that it can’t parse.
        </p>

        <section aria-labelledby="declaration">

            <h2 id="declaration">Declaration</h2>

            <p><abbr>HTML</abbr> and <abbr>CSS</abbr> are both examples of declarative languages. An author writing in a
                declarative language describes a desired outcome without providing step‐by‐step instructions to the
                computer processing the file. With <abbr>HTML</abbr>, you can describe the nature of the
                content—paragraphs, headings, form fields, etc.—without having to explain exactly what the browser
                should do with that information. With <abbr>CSS</abbr>, you can describe the desired appearance of the
                content—colours, borders, etc.—without having to write a program to apply those styles.</p>

            <p>Most programming languages are not declarative, they are imperative. Perl, Java, C++ …these are all
                examples of imperative languages. If you’re writing in one of those languages, you must provide precise
                instructions to the computer interpreting your code.</p>

            <p>Imperative languages provide you with more power and precision than declarative languages. That comes at
                a price. Imperative languages tend to be harder to learn than declarative languages. It’s also harder to
                apply Postel’s Law to imperative languages. If you make a single mistake—one misplaced comma or
                semi‐colon—the entire program may fail. A misspelt tag in <abbr>HTML</abbr> or a missing curly brace in
                <abbr>CSS</abbr> can also cause headaches, but imperative programs must be well‐formed or they won’t run
                at all.
            </p>

            <p>Imperative languages such as <abbr>PHP</abbr>, Ruby, and Python can be found on the servers powering the
                World Wide Web, reading and writing database records, processing input, and running complex algorithms.
                You can choose just about any programming language you want when writing server‐side code. Unlike the
                unknowability of the end user’s web browser, you have control over your server’s capabilities.</p>

            <p>If you want to write imperative code that runs in a web browser, you only have one choice: <span
                    id="JavaScript">JavaScript</span>.</p>

        </section>

        <section aria-labelledby="scripting">

            <h2 id="scripting">Scripting</h2>

            <p>The idea of executing a program from within a web page is as old as the web itself. Here’s an early email
                to the www‐talk mailing list:</p>

            <blockquote>
                <p>I would like to know, whether anybody has extended <abbr>WWW</abbr> such, that it is possible to
                    start arbitrary programs by hitting a button in a <abbr>WWW</abbr> browser.</p>
            </blockquote>

            <p>Tim Berners‐Lee, creator of the World Wide Web, responded:</p>

            <blockquote>
                <p>Very good question. The problem is that of programming language. You need something really powerful,
                    but at the same time ubiquitous. Remember a facet of the web is universal readership. There is no
                    universal interpreted programming language.</p>
            </blockquote>

            <p>That was in 1992. The universal interpreted programming language finally arrived in 1996. It was written
                in ten days by a programmer at Netscape named <span id="Brendan%20Eich">Brendan Eich</span>.</p>

            <p>The language went through a few name changes. First it was called Mocha. Then it was officially launched
                as LiveScript. Then the marketing department swept in and renamed it JavaScript, hoping that the name
                would ride the wave of hype associated with the then‐new Java language. In truth, the languages have
                little in common. Java is to JavaScript as ham is to hamster.</p>

        </section>

        <section aria-labelledby="patternsofprogress">

            <h2 id="patternsofprogress">Patterns of progress</h2>

            <p>JavaScript gave designers the power to update web pages even after they had loaded. Two common uses soon
                emerged: rollovers and form validation.</p>

            <p>Swapping out images when someone hovers their cursor over a link might not seem like a sensible use of a
                brand new programming language, but back in the nineties there was no other way of creating
                hover effects.</p>

            <p>Before JavaScript came along, a form would have to be submitted to a web server before you could check to
                make sure that all the required fields were filled in, or that the information that was entered
                corresponded to an expected format.</p>

            <p>Both of those use cases still exist, but now there’s no need to reach for JavaScript. You can create
                rollover effects using the <code>:hover</code> pseudo‐class in <abbr>CSS</abbr>. You can validate form
                fields using the <code class="markup attribute">REQUIRED</code> and <code
                    class="markup attribute">TYPE</code> attributes in <abbr>HTML</abbr>.</p>

            <p>That’s a pattern that repeats again and again: a solution is created in an imperative language and if
                it’s popular enough, it migrates to a declarative language over time. When a feature is available in a
                declarative language, not only is it easier to write, it’s also more robust.</p>

            <p>The loose error‐handling of <abbr>HTML</abbr> and <abbr>CSS</abbr> means that many authoring mistakes or
                browser support issues are handled gracefully; the browser simply ignores what it doesn’t understand and
                carries on. That’s often good enough. By contrast, if you give a browser some badly‐formed JavaScript or
                attempt to use an unsupported JavaScript feature, not only will the browser throw an error, it will stop
                parsing the script at that point and refuse to go any further.</p>

        </section>

        <section aria-labelledby="responsibility">

            <h2 id="responsibility">Responsibility</h2>

            <p>JavaScript gave web designers the power to create websites that were slicker, smoother, and more
                reactive. The same technology also gave web designers the power to create websites that were sluggish,
                unwieldy, and more difficult to use.</p>

            <p>One of the earliest abuses of JavaScript came (unsurprisingly) from the advertising industry, a business
                whose very raison d’être is often at odds with the goals of people trying to achieve a task as quickly
                as possible. JavaScript allows you to create new browser windows, something that previously could only
                be done by the user. A young developer named <span id="Ethan%20Zuckerman">Ethan Zuckerman</span>
                realised that he could spawn a new window with an advertisement in it. That allowed advertisers to put
                their message in front of website visitors. Not only that, but JavaScript could be used to spawn
                multiple windows, some of them visible, some of them hidden behind the current window. It was a
                fiendish solution.</p>

            <p>Twenty years later, Zuckerman wrote:</p>

            <blockquote>
                <p>I wrote the code to launch the window and run an ad in it. I’m sorry.</p>
            </blockquote>

            <p>Pop‐up (and pop‐under) windows became so intolerable that browsers had to provide people with a means to
                block them.</p>

            <p>The advertising industry later found other ways to abuse JavaScript. Ad‐supported online publishers
                injected bloated and inefficient JavaScript into their pages, making them slow to load. JavaScript was
                also used to track people from site to site. People reached for ad‐blocking software to combat this
                treatment. Eventually ad blocking was built into browsers and operating systems to give us the ability
                to battle excessive JavaScript.</p>

            <p>Web designers would do well to remember what the advertising industry chose to ignore: on the web, the
                user has the final say.</p>

        </section>

        <section aria-labelledby="twopointzero">

            <h2 id="twopointzero">2.0</h2>

            <p>The rise of JavaScript was boosted in 2005 with the publication of an article entitled <cite
                    id="Ajax:%20A%20New%20Approach%20to%20Web%20Applications">Ajax: A New Approach to Web
                    Applications</cite> by <span id="Jesse%20James%20Garrett">Jesse James Garrett</span>. The article
                put a name to a technique that was gaining popularity. Using a specific subset of JavaScript, it was
                possible for a web browser to send and receive data from a web server without refreshing the whole page.
                The result was a smoother user experience.</p>

            <p>The term Ajax was coined at the same time that another neologism was in the ascendent. <span
                    id="Tim%20O’Reilly">Tim O’Reilly</span> used the phrase <span id="Web%202.0">Web 2.0</span> to
                describe a new wave of web products and services. Unlike Ajax, it was difficult to pin down a definition
                of Web 2.0. For business people, it meant new business models. For graphic designers, it meant rounded
                corners and gradients. For developers, it meant JavaScript and Ajax.</p>

            <p>Whatever its exact meaning, the term Web 2.0 captured a mood and a feeling. Everything was going to be
                different now. The old ways of thinking about building for the web could be cast aside. Treating the web
                as a limitless collection of hyperlinked documents was passé. The age of web apps was at hand.</p>

        </section>

        <section aria-labelledby="Appliance">

            <h2 id="appiness">Appliance</h2>

            <p>Dans l'affaire <span id="Jacobellis%20versus%20Ohio">Jacobellis contre Ohio</span>,
                jugée par la Cour suprême en 1964, le juge <span id="Potter%20Stewart">Potter Stewart</span> a donné
                cette définition de l'obscénité :</p>

            <blockquote>
                <p>Je le sais quand je le vois.</p>
            </blockquote>

            <p>On pourrait dire la même chose du Web 2.0, ou du terme "web app". Nous pouvons tous citer des exemples
                d'applications
                web, mais il est plus difficile de donner une définition du terme. Les applications web permettent aux
                gens de créer, de
                modifier et de supprimer du contenu. Mais ces tâches étaient courantes bien avant l'arrivée des
                applications web. Les
                gens pouvaient remplir des formulaires et les soumettre à un serveur web pour traitement. Ajax a
                supprimé la nécessité
                d'un aller-retour au serveur.</p>

            <p>Peut-être la définition d'une application web nécessite-t-elle un raisonnement circulaire :</p>

            <ul>
                <li>JavaScript est une exigence pour une application web, et</li>
                <li>une application web est un site web qui nécessite JavaScript pour fonctionner.</li>
            </ul>

            <p>Dans ce cas, la création d'applications web dépend d'une hypothèse fondamentale : JavaScript doit être disponible et fiable. Mais en raison de sa nature impérative, JavaScript tend à être plus fragile qu'un langage déclaratif comme <abbr>HTML</abbr>. Compter sur JavaScript n'est peut-être pas une hypothèse aussi sûre après tout.
            </p>

        </section>

        <section aria-labelledby="Impardonnable">

            <h2 id="unforgiven">Impardonnable</h2>

            <p>Le traitement souple des erreurs du <abbr>HTML</abbr>lui a permis de gagner en puissance au fil du temps. Il a également permis de garantir la facilité d'apprentissage du langage. Même si vous faites une erreur, l'application de la loi Postel par le navigateur vous garantit un résultat. Étonnamment, il y a eu une tentative de supprimer ce super pouvoir du <abbr>HTML</abbr>.</p>

            <p>Après la normalisation de la version 4 de <abbr>HTML</abbr> en 1999, le World Wide Web Consortium a publié
                <abbr id="XHTML">XHTML</abbr> 1.0. Celui-ci a reformulé le <abbr>HTML</abbr> selon les règles du format de données
                <abbr id="XML">XML</abbr>. Alors que le <abbr>HTML</abbr> peut avoir des noms de balises et des attributs en majuscules ou en minuscules, le <abbr>XML</abbr> exige qu'ils soient tous en minuscules. Il y avait d'autres différences : tous les attributs doivent être cités, et les éléments autonomes comme les <code
                    class="markup element">IMG</code> ou les <code class="markup element">BR</code> nécessitent un slash.
            </p>

            <p>Le <abbr>XHTML</abbr> n'a pas ajouté de nouvelles fonctionnalités au langage. Il s'agit simplement d'une façon plus stricte d'écrire les balises. Le <abbr>XHTML</abbr> était une proposition différente. Non seulement il supprimait des éléments établis comme <code class="markup element">IMG</code>, mais il mettait également en œuvre le modèle draconien de traitement des erreurs du <abbr>XML</abbr>. S'il y a une seule erreur dans un document <abbr>XML</abbr>—un attribut non cité ou un slash manquant—l'analyseur devrait alors s'arrêter immédiatement et refuser de produire quoi que ce soit.</p>

            <p>Le <abbr>XHTML</abbr> 2.0 est mort sur la vigne. Sa pureté théorique a été rejetée par les personnes qui ont créé des sites web pour gagner leur vie. Les concepteurs de sites web ont refusé à juste titre de publier dans un format qui échouerait complètement au lieu d'essayer de se remettre d'une erreur.</p>

            <p>Il est donc étrange que, des années plus tard, les concepteurs de sites web se contentent de créer des sites entiers en utilisant JavaScript, un langage qui partage l'impitoyable modèle de traitement des erreurs de <abbr>XML</abbr>. Ils ne les appelaient pas des sites web. Ils les appelaient des applications web. Cette distinction n'était qu'une maigre consolation pour quelqu'un qui ne pouvait pas accomplir sa tâche parce qu'un service dépendait de JavaScript pour une fonctionnalité cruciale.</p>

            <p>Malgré la fragilité du modèle de traitement des erreurs de JavaScript, les concepteurs de sites web sont devenus de plus en plus dépendants de JavaScript au fil du temps. En 2015, la <abbr id="NASA">NASA</abbr> a lancé son site web sous forme d'application web. Si vous voulez lire les dernières nouvelles des efforts d'exploration spatiale de l'agence, vous devez d'abord télécharger et exécuter trois mégaoctets de JavaScript. Ce contenu-texte et images-aurait pu être livré en
                <abbr>HTML</abbr>, mais les développeurs ont décidé d'utiliser Ajax pour récupérer ces données à la place. Jusqu'à ce que tout ce JavaScript soit chargé, analysé et exécuté, les visiteurs du site restaient devant un fond noir. Peut-être cela était-il destiné à démontrer le vaste vide solitaire de l'espace.
            </p>

            <figure>
                <picture>
                    <source media="all and (min-width: 75em)" srcset="images/large/nasa.png" />
                    <source media="all and (min-width: 50em)"
                        srcset="images/medium/nasa.png, images/large/nasa.png 1.5x" />
                    <img src="images/small/nasa.png" alt="A web browser showing a black screen."
                        srcset="images/medium/nasa.png 2x, images/large/nasa.png 3x" />
                </picture>
                <figcaption>La version de 2015 du site nasa.gov avec un JavaScript incomplet.</figcaption>
            </figure>

            <p>Cela met en évidence une autre différence entre <abbr>HTML</abbr> et JavaScript. Alors que le <abbr>HTML</abbr>
                peut être rendu morceau par morceau au fur et à mesure de son téléchargement, un fichier JavaScript doit être téléchargé dans son intégralité avant que son contenu puisse être analysé. Bien qu'il soit tentant de penser que seule une petite minorité de visiteurs n'aura pas accès au JavaScript d'un site, la vérité est que tout le monde est un utilisateur non-JavaScript jusqu'à ce que le JavaScript ait fini de se charger ...<em>si</em> le JavaScript finit de se charger. Des connexions défaillantes, des opérateurs de réseau interférents et des logiciels de blocage des publicités imprévisibles peuvent torpiller l'hypothèse selon laquelle le JavaScript sera toujours disponible.</p>

            <p>Le problème n'est pas que les gens désactivent délibérément le JavaScript dans leur navigateur. Bien que ce soit un cas d'utilisation qui mérite d'être pris en considération, ce n'est pas la cause la plus fréquente des erreurs de JavaScript. <span
                    id="Stuart%20Langridge">Stuart Langridge</span> a dressé une liste de tous les points d'échec potentiels sous le titre <cite id="Everyone%20has%20JavaScript,%20right?">Tout le monde a JavaScript, n'est-ce pas ?</cite></p>

            <blockquote>
                <p>L'utilisateur demande votre application web. La page s'est-elle déjà chargée ? La requête <abbr>HTTP</abbr> pour le JavaScript a-t-elle réussi ? La demande <abbr>HTTP</abbr> pour le JavaScript a-t-elle abouti ? Le pare-feu de l'entreprise bloque-t-il le JavaScript ? Leur <abbr>FAI</abbr> ou leur opérateur mobile interfère-t-il avec le JavaScript téléchargé ? Ont-ils désactivé JavaScript ? Ont-ils installé des add-ons ou des plug-ins qui injectent du script ou modifient le <abbr>DOM</abbr> d'une manière que vous n'aviez pas prévue ? Le réseau de diffusion de contenu est-il opérationnel ? Leur navigateur prend-il en charge le JavaScript que vous avez écrit ?</p>
            </blockquote>

            <p>Nombre de ces problèmes affecteraient également les fichiers <abbr>HTML</abbr> et <abbr>CSS</abbr> mais grâce à la loi de Postel, ils peuvent se rétablir.</p>

            <p>This doesn’t mean that web designers shouldn’t use JavaScript. But it does mean that web designers
                shouldn’t <em>rely</em> on JavaScript when a simpler solution exists.</p>

        </section>

        <section aria-labelledby="Plate-forme">

            <h2 id="platform">Plate-forme</h2>

            <p>Les concepteurs de sites web qui ont ignoré le message <cite>A Dao of Web Design</cite> de John Allsopp ont commis l'erreur de traiter le web comme un imprimé. L'histoire de l'imprimé a beaucoup à offrir-hiérarchie, typographie, théorie des couleurs-mais le web est un média fondamentalement différent. L'histoire du développement de logiciels a également beaucoup à offrir-architecture, tests, processus-mais là encore, le web reste son propre support.</p>

            <p>Il est tentant d'appliquer au web les connaissances et les enseignements d'un autre média. Mais il est structurellement plus honnête de découvrir les forces et faiblesses propres au web.</p>

            <p>Le langage que nous utilisons peut subtilement influencer notre réflexion. Dans son livre <cite
                    id="Metaphors%20We%20Live%20By">Metaphors We Live By</cite>, <span id="George%20Lakoff">George
                    Lakoff</span> souligne les dangers du langage politique. Les exemples évidents sont le "tir sur un ami" et les “dommages collatéraux”, mais un exemple plus insidieux est celui des “allégements fiscaux” - avant même qu'un débat n'ait commencé, la fiscalité a été présentée comme quelque chose qui nécessite un allégement.</p>

            <p>À première vue, le terme "plate-forme web" semble inoffensif. Décrire le web comme une plate-forme le met au même niveau que d'autres environnements logiciels. Flash était une plate-forme. Android est une plateforme. i<abbr>OS</abbr> iest une plateforme. Mais le web n'est pas une plateforme. L'intérêt du web est qu'il est
                <em>multi</em>‐plateforme.
            </p>

            <p>Une plate-forme fournit un environnement d'exécution contrôlé pour les logiciels. Tant que l'utilisateur dispose de cet environnement d'exécution, vous pouvez être sûr qu'il obtiendra exactement ce que vous avez conçu. Si vous créez une application i<abbr>OS</abbr> et que quelqu'un possède un appareil sous i<abbr>OS</abbr>, vous savez qu'il obtiendra 100% de votre logiciel. Mais si vous créez une application iOS et que quelqu'un possède un appareil Android, il obtiendra 0 % de vos logiciels. Vous ne pouvez pas installer une application i<abbr>OS</abbr> app and someone has an Android device, they will get
                0% of your software. You can’t install an i<abbr>OS</abbr> sur un appareil Android. C'est tout ou rien.</p>

            <p>Le web n'est pas aussi binaire que cela. Si vous construisez quelque chose en utilisant les technologies web, et que quelqu'un vous visite avec un navigateur web, vous ne pouvez pas être sûr du nombre de technologies web qui seront supportées. Mais ça ne sera probablement pas 100%. Mais il est également peu probable que ce soit 0 %. Certaines personnes visiteront avec des appareils i<abbr>OS</abbr>. D'autres utiliseront des appareils Android. Certaines personnes obtiendront 80% ou 90 % de ce que vous avez conçu. D'autres n'obtiendront que 20 %, 30 % ou 50 %. Le web n'est pas une plateforme. C'est un continuum.</p>

            <p>Penser le web comme une plateforme est une erreur de catégorie. Une plateforme comme Flash, i<abbr>OS</abbr>ou Android offre stabilité et certitude, mais uniquement dans des circonstances très spécifiques : votre logiciel doit être accessible avec un environnement d'exécution adapté à la plateforme. Le web ne fournit pas cette certitude, mais il ne restreint pas non plus les environnements d'exécution possibles.</p>

            <p>Les plates-formes sont contrôlées et prévisibles. Le World Wide Web est chaotique et imprévisible.</p>

            <p>Le web est un véritable gâchis.</p>

        </section>

        <aside>
            <h2>Références</h2>
            <ol>
                <li><a href="https://tools.ietf.org/html/rfc761#section-2.10"><abbr>RFC</abbr> 761: <cite>Transmission
                            Control Protocol</cite></a> par Jon Postel</li>
                <li><a href="https://lists.w3.org/Archives/Public/www-talk/1992MayJun/0006.html"><cite>Program Links in
                            <abbr>WWW</abbr></cite></a> par Tim Berners‐Lee</li>
                <li><a
                        href="http://www.theatlantic.com/technology/archive/2014/08/advertising-is-the-internets-original-sin/376041/"><cite>The
                            Internet’s Original Sin</cite></a> par Ethan Zuckerman</li>
                <li><a
                        href="https://web.archive.org/web/20150910072359/http://adaptivepath.org/ideas/ajax-new-approach-web-applications/"><cite>Ajax:
                            A New Approach to Web Applications</cite></a> par Jesse James Garrett</li>
                <li><a href="https://kryogenix.org/code/browser/everyonehasjs.html"><cite>Everyone has JavaScript,
                            right?</cite></a> par Stuart Langridge</li>
            </ol>
        </aside>

    </main>

    <nav>
        <a href="../chapter3/" rel="next"><cite><span>Chapitre 5:</span> Couches</cite></a>
        <ol start="0">
            <li><a href="../introduction/"><cite>Introduction</cite></a></li>
            <li><a href="../chapter1/"><cite><span>Chapitre 1</span> Fondations</cite></a></li>
            <li><a href="../chapter2/"><cite><span>Chapitre 2</span> Matériaux</cite></a></li>
            <li><a href="../chapter3/"><cite><span>Chapitre 3</span> Visions</cite></a></li>
            <li><a href="../chapter4/"><cite><span>Chapitre 4</span> Langages</cite></a></li>
            <li><a href="../chapter5/"><cite><span>Chapitre 5</span> Couches</cite></a></li>
            <li><a href="../chapter6/"><cite><span>Chapitre 6</span> Etapes</cite></a></li>
            <li><a href="../chapter7/"><cite><span>Chapitre 7</span> Défis</cite></a></li>
            <li><a href="../author/" rel="author"><cite>A propos de l'auteur</cite></a></li>
            <li><a href="../index/"><cite>Index</cite></a></li>
        </ol>
    </nav>
    <footer>
        <p><cite>Resilient Web Design</cite> a été écrit et produit par <a href="https://adactio.com"
                class="v‐card">Jeremy Keith</a>, et composé en <a
                href="https://edwardtufte.github.io/et-book/"><abbr>ET</abbr> Book</a>.</p>
        <p><small>Licencié sous un <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative
                    Commons Attribution‐ShareAlike 4.0 International License</a>.</small></p>
    </footer>

    <script src="../js/scripts.js" defer></script>
</body>

</html>